/* XV Linux/x86-64 build | Spencer Tipping */
/* Licensed under the terms of the MIT source code license */

/* Bootup code. */
/* The handoff here is kind of strange, but it helps partition the rest of the */
/* source into header files. The problem is that TinyELF runs the first concrete */
/* function, so if we were to do the normal thing of including headers first, then */
/* those headers wouldn't be able to define concrete functions. */

/* As it is, we can define a stub `_start` function that kicks off to the */
/* forward-defined `xv_main`, then put `#include` directives after this. */

#include <sys/types.h>
void xv_main(void);
void xv_warp(off_t offset);
void _start(void) {
  /* Jump from here straight into the body of the xv_main() function. */
  xv_warp((off_t) &xv_main - (off_t) &_start);
}

/* Library inclusion. */
/* At this point we can load the header files. */

#include "xv-x64-defs.h"
#include "xv-generic.h"
#include "xv-mmap-linux.h"
#include "xv-x64-linux-syscall.h"
#include "xv-x64-virt.h"

/* Main entry point. */
/* We need to parse argv, argc, and the environment variables. These will */
/* ultimately be handed to the subprocess, but only once we've consumed some of */
/* them. */

void xv_main(void) {
  /* This function is never called, but its body gets jumped into from _start.
   * Therefore, we inherit its stack verbatim, which is the one given to new
   * programs by the Linux process loader. */
}

/* End header. */
/* This is required for XV to be able to figure out how large its image is in */
/* memory. See `xv-end.h` for details about this. */

#include "xv-end.h"

/* Generated by SDoc */
