/* XV x86-64 syscall virtualization | Spencer Tipping */
/* Licensed under the terms of the MIT source code license */

/* Introduction. */
/* This module rewrites x86-64 instruction streams and replaces any system call */
/* instructions with an illegal instruction that will trigger a SIGILL in the */
/* virtualized process. It also provides memory protection handlers to prevent */
/* dynamically-generated code from generating unmanaged system calls. */

#ifndef XV_X64_VIRT_H
#define XV_X64_VIRT_H

#define XV_DEFINED_VIRT

void xv_warp(ptrdiff_t offset) {
  asm volatile ("lea (%0,%%rip,1), %0;"
                "jmp *%0;"
              :
              : "r"(offset)
              : "cc");
}

void xv_goto(void* addr) {
  asm volatile ("jmp *%0;"
              :
              : "r"(addr));
}

/* Virtualizer. */
/* This is actually pretty simple. Each of the syscall instructions on x86-64 is */
/* two bytes long, and we can easily construct a two-byte instruction that is */
/* totally invalid. The only tricky part is keeping track of the address space */
/* state. */

#endif

/* Generated by SDoc */
