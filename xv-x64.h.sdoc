XV instruction stream rewriter: x86-64
Copyright (C) 2013, Spencer Tipping
Released under the terms of the GPLv3: http://www.gnu.org/licenses/gpl-3.0.txt

Introduction.
This file provides all definitions relevant to instruction stream rewriting for
x86-64 instructions. It assumes that the instruction stream is being
interpreted in 64-bit mode, not 32-bit compatibility mode.

#ifndef XV_X64_H
#define XV_X64_H

#include "xv.h"

#include <elf.h>
#include <stdint.h>
#include <sys/types.h>

Rewriting strategy.
Rewriting is a closed transformation: i.e. there is no runtime interaction that
needs to happen to maintain the abstraction. The only exception is runtime code
generation, which is detected by listening for segfaults against the
write-protected original code. (Any such segfault invalidates the cached
basic-blocks that refer to it.)

Internally, the transformation consists of rewriting the code to preserve the
invariant that all addressing logic is done using unmodified addresses. For
absolute addresses this is trivial, and for %rip-relative addressing it means
adjusting (or adding) the displacement for each memory-accessing instruction.

Syscall opcodes, of which there are three, are each rewritten as calls into
libxv. These calls aren't standard C calls; they're literally x86-64 CALL
instructions that go to a receiver site in libxv. This receiver site then reads
the relevant registers and performs or emulates the system call itself.

typedef unsigned char       xv_x64_i;
typedef unsigned char const xv_x64_const_i;

typedef struct {
  xv_x64_i *start;                      /* start of allocated region */
  xv_x64_i *current;                    /* current insertion point */
  ssize_t   capacity;                   /* size (bytes) of allocated region */
} xv_x64_ibuffer;

typedef struct {
  xv_x64_const_i *start;
  xv_x64_const_i *current;
  ssize_t         capacity;
} xv_x64_const_ibuffer;

typedef struct {
  xv_x64_const_ibuffer src;             /* original instructions */
  xv_x64_ibuffer       dst;             /* recompiled instruction stream */
  void                *xv_entry_point;  /* system call hook address */
} xv_x64_rewriter;

int xv_ibuffer_init(xv_x64_ibuffer *buf);
int xv_ibuffer_free(xv_x64_ibuffer *buf);

/* Write a single literal instruction into the specified buffer, resizing
 * backing allocation structures as necessary. The buffer's "current" pointer
 * is advanced to the next free position. */
int xv_write_insn(xv_x64_ibuffer *buf,
                  xv_x64_const_i *insn);

/* Read a single instruction from the given const buffer, advancing the buffer
 * in the process. */
int xv_read_insn(xv_x64_const_ibuffer *buf,
                 xv_x64_insn          *result);

/* Possible return values for xv_read_insn */
#define XV_READ_ERR  -1 /* internal error; read errno */
#define XV_READ_CONT  0 /* no problems; can read next instruction */
#define XV_READ_END   1 /* hit end of stream (source is invalid) */

/* Rewrite a single instruction from src to dst, updating both */
int xv_step_rw(xv_x64_rewriter* rw);

/* Possible return values for xv_step_rw */
#define XV_RW_ERR  -1   /* internal error; read errno */
#define XV_RW_CONT  0   /* no problems; can continue */
#define XV_RW_END   1   /* hit end of stream (source is invalid) */
#define XV_RW_JMP   2   /* last instruction was unconditional jump */
#define XV_RW_JCC   3   /* last instruction was conditional jump */

Instruction metadata.
Instruction argument encodings indexed by key, which in this case is a ten-bit
quantity that indicates the opcode escape path:

| 00 xxxxxxxx   <- one-byte opcode xxxxxxxx
  01 xxxxxxxx   <- two-byte opcode xxxxxxxx
  10 xxxxxxxx   <- three-byte opcode escaped with 0x38
  11 xxxxxxxx   <- three-byte opcode escaped with 0x3a

There are also a bunch of predicate macros to check for prefix, REX, VEX, and
other types of bytes. These take an xv_x64_iptr or xv_x64_const_iptr and return
0 or 1.

typedef struct {
  unsigned int p1 : 2;
  unsigned int p2 : 3;
  unsigned int p3 : 1;
  unsigned int p4 : 1;
  unsigned int    : 1;

  unsigned int rex    : 4;      /* for VEX, stores WRXB */
  unsigned int vex_v4 : 4;
  unsigned int vex_m5 : 5;
  unsigned int vex_l  : 1;
  unsigned int vex_pp : 2;

  unsigned int escape  : 2;
  unsigned int modrm_t : 1;
  unsigned int imm_t   : 3;
  unsigned int         : 2;

  unsigned int opcode : 8;
  unsigned int mod    : 2;
  unsigned int modr   : 3;
  unsigned int modm   : 3;
  unsigned int s      : 2;
  unsigned int i      : 3;
  unsigned int b      : 3;

  union {
    int64_t disp64;
    int32_t disp32;
    int8_t  disp8;
  };

  union {
    int64_t imm64;
    int32_t imm32;
    int8_t  imm8;
  };
} xv_x64_insn;

Operand encodings.
These are used for two purposes. First, we need them to indicate the length of
the remainder of the instruction; and second, we need to figure out how memory
is accessed and change the ModR/M and SIB bytes for %rip-relative instructions.

#define XV_MODRM_NONE 0         /* instruction uses no ModR/M byte */
#define XV_MODRM_MEM  1         /* uses ModR/M byte to refer to memory */

#define XV_IMM_NONE 0           /* no immediate data following ModR/M (or op) */
#define XV_IMM_D8   1           /* 8-bit displacement immediate, e.g. JMP */
#define XV_IMM_D32  2           /* 32-bit displacement immediate */
#define XV_IMM_I8   3           /* 8-bit invariant immediate, e.g. INT */
#define XV_IMM_I16  4           /* 16-bit invariant immediate, e.g. MOV */
#define XV_IMM_I32  5           /* 32-bit invariant immediate */
#define XV_IMM_I64  6           /* 64-bit invariant immediate */

#define XV_INSN_ESC0   0        /* xv_x64_insn.escape */
#define XV_INSN_ESC1   1
#define XV_INSN_ESC238 2
#define XV_INSN_ESC23A 3

#define XV_INSN_LOCK  1         /* xv_x64_insn.p1 */
#define XV_INSN_REPNZ 2
#define XV_INSN_REPZ  3

#define XV_INSN_CS 1            /* xv_x64_insn.p2 */
#define XV_INSN_SS 2            /* note that CS == branch not taken, */
#define XV_INSN_DS 3            /*           DS == branch taken */
#define XV_INSN_ES 4
#define XV_INSN_FS 5
#define XV_INSN_GS 6

#define XV_INSN_66 1            /* xv_x64_insn.p3 */

#define XV_INSN_67 1            /* xv_x64_insn.p4 */

Prefix detectors.
These are used against xv_x64_const_iptrs to figure out what kind of
instruction you have. (See xv-x64.c for details.)

#define XV_G1P(iptr) (*(iptr) == 0xf0 || \
                      *(iptr) == 0xf2 || \
                      *(iptr) == 0xf3)

#define XV_G2P(iptr) (*(iptr) == 0x2e || *(iptr) == 0x36 || \
                      *(iptr) == 0x3e || *(iptr) == 0x26 || \
                      *(iptr) == 0x64 || *(iptr) == 0x65)

#define XV_G3P(iptr) (*(iptr) == 0x66)
#define XV_G4P(iptr) (*(iptr) == 0x67)

#define XV_REXP(iptr)  ((*(iptr) & 0xf0) == 0x40)
#define XV_VEX3P(iptr) (*(iptr) == 0xc4)
#define XV_VEX2P(iptr) (*(iptr) == 0xc5)

#define XV_OPESC1P(iptr) (*(iptr) == 0x0f)
#define XV_OPESC2P(iptr) (*(iptr) == 0x38 || *(iptr) == 0x3a)

Basic blocks.
Each basic block knows the translation address, and basic blocks are stored in
a sorted structure so we can trace segfault addresses back to the corresponding
piece of code. (This will happen anytime the code attempts to modify itself.)

In addition, basic blocks provide flags, which indicate various possibly-useful
properties. For example, we mark any basic block that doesn't have any
memory-writing operations, and we mark those that make no system calls.

We also need to keep track of the kind of jump the block uses. Each basic block
will end for a specific reason, often because we encountered a jump
instruction. We store the type of ending on the basic block so we can recover
the target address without reparsing it.

#define XV_NO_SYS   (1 << 0)    /* the basic block makes no system calls */
#define XV_NO_WRITE (1 << 1)    /* the basic block does not write to memory */

typedef struct {
  xv_x64_const_i *addr;         /* starting absolute address */
  ssize_t         size;         /* size (bytes) of original */
  xv_x64_const_i *end_insn;     /* beginning of jump instruction (0 if none) */
  xv_x64_const_i *t_addr;       /* translation cache address (0 if none) */
  uint64_t        flags;        /* see above for values */
} xv_x64_bblock;

typedef struct {
  xv_x64_bblock *blocks;        /* array of blocks, always sorted by addr */
  int            size;          /* number of used block entries */
  int            capacity;      /* total number of block entries */
} xv_x64_bblock_list;

int xv_bblock_list_init(xv_x64_bblock_list *bblock_list);
int xv_bblock_list_free(xv_x64_bblock_list *bblock_list);

/* Return index of basic block containing specified addr, -1 if none; runs in
 * O(log n) time */
int xv_bblock_idx(xv_x64_const_i           *addr,
                  const xv_x64_bblock_list *bblock_list);

/* Add bblock to list, maintaining sort order; runs in O(n) time */
int xv_add_bblock(xv_x64_bblock const *bblock,
                  xv_x64_bblock_list  *bblock_list);

/* Rewrite jump target addresses within specified bblock, causing code to jump
 * directly to other already-rewritten basic blocks rather than into
 * untranslated code (which would cause a segfault that we would intercept) */
int xv_link_bblock(xv_x64_bblock_list *bblock_list,
                   int                 idx);

ELF reader.
All of the machine code coming into the rewriter is probably going to be
encased in ELF objects. This is useful for us because we can easily map the ELF
into memory, then use the symbol table to build a list of basic blocks.

Some (admittedly rare and bizarre) ELF objects have invalid symbol tables or
other such nonsense. In this case, we can use the entry point (for
executables), or we can wait for code to be executed and catch the resulting
segfault, having then discovered the address of a basic block or fragment.

/* Add all basic blocks from in-memory ELF image; idempotent, and runs in
 * O((k + n)Â²) time, where k = #bblocks in ELF and n = size of bblock list */
int xv_elf_into_bblocks(const void         *elf_image,
                        xv_x64_bblock_list *bblock_list);

#endif
